<!DOCTYPE html>
<html lang="en">
<head>
    
    <link rel="canonical" href="https://gaming-with-fahim.pages.dev/">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Crush Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;900&display=swap" rel="stylesheet">
   
   <!--Hiltop video slider05-->
<script>
(function(muz){
var d = document,
    s = d.createElement('script'),
    l = d.scripts[d.scripts.length - 1];
s.settings = muz || {};
s.src = "\/\/tatteredpassenger.com\/bRXzV.sbdZGBlQ0nY\/W-cY\/deHmf9Wu\/ZmUilMkQPaTNYL3AMbDXMnypOfT\/AVtgN\/jlcqwQMJzbIy5zMfQF";
s.async = true;
s.referrerPolicy = 'no-referrer-when-downgrade';
l.parentNode.insertBefore(s, l);
})({})
</script>

    <!--GA4-->
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MC9MB92PM9"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MC9MB92PM9');
</script>

    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
        }
        .candy-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border: 6px solid #4b5563;
            
            /* Use fluid units and max-size for responsiveness */
            width: 95vw; /* Start with 95% of viewport width */
            height: 95vw;
            max-width: 500px; /* Don't let it get too wide on desktop */
            max-height: 500px;
        }
        .candy {
            display: flex;
            align-items: center;
            justify-content: center;
            /* Use a fluid size based on the grid size */
            font-size: 6vw; 
            cursor: pointer;
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            border-radius: 0.5rem; 
            margin: 2px;
            aspect-ratio: 1 / 1; 
            animation: fall 0.5s ease-out;
            position: relative; 
        }

        /* Adjust candy font size for larger screens (when max-width is hit) */
        @media (min-width: 500px) {
             .candy {
                /* If 500px is the max width, 6vw is approx 30px. We use slightly larger for desktop feel. */
                font-size: 2.25rem; /* ~36px */
            }
        }

        .candy:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .selected {
            transform: scale(1.15);
            outline: 4px solid #fcd34d; 
            box-shadow: 0 0 20px #fcd34d;
            z-index: 10;
        }

        @keyframes fall {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(236, 72, 153, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(236, 72, 153, 0); }
        }
        .color-bomb-pulse {
            animation: pulse 1.5s infinite;
        }
        
        /* Special candy text size (now fluid) */
        .striped-icon {
            font-size: 3.5vw; /* Scalable star */
        }
        .bomb-icon {
            font-size: 5vw; /* Scalable bomb */
        }
        
        @media (min-width: 500px) {
            .striped-icon {
                font-size: 1.5rem; /* ~24px fixed size */
            }
            .bomb-icon {
                font-size: 2.25rem; /* ~36px fixed size */
            }
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="max-w-lg w-full bg-gray-800 p-4 md:p-6 rounded-xl shadow-2xl">
        
        <h1 class="text-3xl md:text-4xl font-extrabold text-white text-center mb-4 tracking-wider">
            Candy Crush Enhanced ðŸ’¥
        </h1>

        <div class="flex flex-wrap md:flex-nowrap justify-between text-base md:text-lg font-bold text-gray-300 mb-4">
            
            <div class="p-2 bg-gray-700 rounded-lg shadow-inner flex-1 w-full md:w-auto mr-0 md:mr-2 mb-2 md:mb-0">
                Score: <span id="score" class="text-yellow-400">0</span>
            </div>
            
            <div class="p-2 bg-gray-700 rounded-lg shadow-inner flex-1 w-full md:w-auto mx-0 md:mx-2 mb-2 md:mb-0 text-center">
                High Score: <span id="high-score" class="text-pink-400">0</span>
            </div>
            
            <div class="p-2 bg-gray-700 rounded-lg shadow-inner flex-1 w-full md:w-auto ml-0 md:ml-2">
                Moves: <span id="moves" class="text-red-400">30</span>
            </div>
        </div>

        <div id="game-board" class="candy-grid bg-gray-900 border-gray-600 mx-auto my-4">
            </div>

        <div id="message-box" class="mt-4 md:mt-6 text-center text-sm md:text-xl font-bold p-3 rounded-lg transition duration-300 ease-in-out min-h-[50px]">
            <span class="text-green-400">Welcome! Match 4 for a Striped candy (â˜…), or 5 for a Color Bomb (ðŸ’£)!</span>
        </div>

        <button id="reset-button" class="mt-4 w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-extrabold rounded-lg shadow-lg transform hover:scale-[1.01] transition duration-150">
            Start New Game
        </button>

    </div>

    <script type="module">
        // --- Core Game Configuration ---
        const GRID_SIZE = 10;
        const MOVES_LIMIT = 30;
        const BASE_CANDY_TYPES = [
            'ðŸ¬', // Candy
            'ðŸ­', // Lollipop
            'ðŸ¥', // Kiwi
            'ðŸŠ', // Orange
            'ðŸ‡', // Grapes
            'ðŸ’'  // Cherries
        ];
        // Specials Identifiers (Suffix for Striped, unique string for Color Bomb)
        const STRIPED_SUFFIX = 'S';
        const COLOR_BOMB_TYPE = 'CB'; 
        const HIGH_SCORE_KEY = 'geminiCrushHighScore'; // KEY FOR LOCAL STORAGE

        // --- Game State Variables ---
        let board = []; // Stores strings like 'ðŸ¬', 'ðŸ­S', or 'CB'
        let score = 0;
        let moves = MOVES_LIMIT;
        let highScore = 0; // NEW: High Score state
        let selectedCandyIndex = -1;
        let isProcessing = false;

        // --- DOM Elements ---
        const boardEl = document.getElementById('game-board');
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        const messageBox = document.getElementById('message-box');
        const resetButton = document.getElementById('reset-button');
        const highScoreEl = document.getElementById('high-score'); // NEW: High Score Element

        // --- Utility Functions ---

        /**
         * Converts 1D index to 2D coordinates (row, col).
         * @param {number} index
         * @returns {{row: number, col: number}}
         */
        const indexToCoords = (index) => ({
            row: Math.floor(index / GRID_SIZE),
            col: index % GRID_SIZE,
        });

        /**
         * Converts 2D coordinates (row, col) to 1D index.
         * @param {number} row
         * @param {number} col
         * @returns {number}
         */
        const coordsToIndex = (row, col) => row * GRID_SIZE + col;

        /**
         * Gets a random basic candy type (emoji).
         * @returns {string}
         */
        const getRandomCandy = () => BASE_CANDY_TYPES[Math.floor(Math.random() * BASE_CANDY_TYPES.length)];

        /**
         * Extracts the base candy emoji from the board string (e.g., 'ðŸ­S' -> 'ðŸ­').
         * @param {string} candyString
         * @returns {string}
         */
        const getBaseType = (candyString) => {
            if (!candyString) return '';
            if (candyString === COLOR_BOMB_TYPE) return 'ðŸŒˆ'; 
            return BASE_CANDY_TYPES.find(c => candyString.startsWith(c)) || candyString;
        };
        
        /**
         * Checks if a candy is a striped special.
         */
        const isStriped = (candyString) => candyString && candyString.endsWith(STRIPED_SUFFIX);

        /**
         * Checks if a candy is a color bomb.
         */
        const isColorBomb = (candyString) => candyString === COLOR_BOMB_TYPE;

        /**
         * Displays a temporary message in the message box.
         * @param {string} msg
         * @param {string} colorClass - Tailwind text color class
         */
        const showMessage = (msg, colorClass = 'text-green-400') => {
            messageBox.innerHTML = `<span class="${colorClass}">${msg}</span>`;
            setTimeout(() => {
                if (messageBox.firstChild && messageBox.firstChild.textContent === msg) {
                     messageBox.innerHTML = '<span class="text-green-400">Match 4 for Striped, 5 for Color Bomb!</span>';
                }
            }, 3000);
        };

        // --- High Score Functions ---

        /**
         * Loads the high score from local storage.
         */
        const loadHighScore = () => {
            try {
                const savedScore = localStorage.getItem(HIGH_SCORE_KEY);
                highScore = savedScore ? parseInt(savedScore, 10) : 0;
            } catch (error) {
                console.error("Could not load high score from localStorage:", error);
                highScore = 0;
            }
        };

        /**
         * Saves the new high score to local storage.
         * @param {number} newScore
         */
        const saveHighScore = (newScore) => {
             try {
                localStorage.setItem(HIGH_SCORE_KEY, newScore.toString());
                highScore = newScore;
            } catch (error) {
                console.error("Could not save high score to localStorage:", error);
            }
        };


        // --- Game Initialization & Setup ---

        /**
         * Creates the initial board array and fills the DOM grid.
         * Ensures no initial matches of 3 or more.
         */
        const createBoard = () => {
            board = Array(GRID_SIZE * GRID_SIZE).fill(null).map(() => getRandomCandy());

            // Simple initial check to prevent immediate matches (slows load slightly)
            let hasMatch = true;
            while (hasMatch) {
                hasMatch = false;
                for (let i = 0; i < board.length; i++) {
                    const { row, col } = indexToCoords(i);
                    let candy = getBaseType(board[i]);

                    // Check horizontal match
                    if (col >= 2) {
                        const base1 = getBaseType(board[i - 1]);
                        const base2 = getBaseType(board[i - 2]);
                        if (candy === base1 && candy === base2) {
                            board[i] = getRandomCandy(); // Replace and re-check this spot
                            hasMatch = true;
                            continue;
                        }
                    }
                    // Check vertical match
                    if (row >= 2) {
                        const base1 = getBaseType(board[i - GRID_SIZE]);
                        const base2 = getBaseType(board[i - 2 * GRID_SIZE]);
                        if (candy === base1 && candy === base2) {
                            board[i] = getRandomCandy(); // Replace and re-check this spot
                            hasMatch = true;
                        }
                    }
                }
            }
            renderBoard();
        };

        /**
         * Renders the game board based on the current 'board' array.
         */
        const renderBoard = () => {
            boardEl.innerHTML = '';
            board.forEach((candy, index) => {
                const baseType = getBaseType(candy);
                
                const candyEl = document.createElement('div');
                candyEl.classList.add('candy', 'bg-gray-700', 'rounded-lg', 'shadow-md', 'active:shadow-inner');
                candyEl.textContent = baseType;
                candyEl.dataset.index = index;
                candyEl.addEventListener('click', () => handleCandyClick(index));

                // Apply special styling and content
                if (isStriped(candy)) {
                    // Striped Candy: Yellow Border + Star Overlay
                    candyEl.classList.add('border-4', 'border-yellow-400', 'bg-yellow-800/50');
                    // Uses fluid CSS class 'striped-icon' for star size
                    candyEl.innerHTML = `<div class="relative w-full h-full flex items-center justify-center">
                        ${baseType} 
                        <span class="absolute font-extrabold text-white -top-1 right-0 transform rotate-12 striped-icon">â˜…</span>
                    </div>`;
                } else if (isColorBomb(candy)) {
                    // Color Bomb: Pink Pulsing Background + Bomb Icon
                    candyEl.classList.add('bg-pink-600', 'color-bomb-pulse', 'shadow-2xl');
                    // Uses fluid CSS class 'bomb-icon' for bomb size
                    candyEl.innerHTML = `<div class="relative w-full h-full flex items-center justify-center">
                        <span class="bomb-icon">ðŸ’£</span>
                    </div>`;
                }
                
                boardEl.appendChild(candyEl);
            });
            scoreEl.textContent = score;
            movesEl.textContent = moves;
            highScoreEl.textContent = highScore; // Display High Score
        };

        // --- Game Logic ---

        /**
         * Swaps two candies in the board array and re-renders.
         */
        const swapCandies = (index1, index2) => {
            if (index1 === index2) return;
            [board[index1], board[index2]] = [board[index2], board[index1]];
            renderBoard();
        };

        /**
         * Checks if two indices are adjacent (horizontally or vertically).
         */
        const isAdjacent = (index1, index2) => {
            const { row: r1, col: c1 } = indexToCoords(index1);
            const { row: r2, col: c2 } = indexToCoords(index2);
            return (r1 === r2 && Math.abs(c1 - c2) === 1) || (c1 === c2 && Math.abs(r1 - r2) === 1);
        };

        /**
         * Activates the Color Bomb, clearing all candies of a specified type.
         * @param {number} bombIndex - Index of the color bomb.
         * @param {string} targetCandyType - The base type of candy to clear (e.g., 'ðŸ¬').
         */
        const activateColorBomb = async (bombIndex, targetCandyType) => {
            showMessage(`COLOR BOMB DETONATION! Clearing all ${targetCandyType}!`, 'text-purple-400');

            const crushIndices = [];
            for (let i = 0; i < board.length; i++) {
                // Check if the candy matches the target base type OR if it's the bomb itself
                if (getBaseType(board[i]) === targetCandyType || i === bombIndex) {
                    crushIndices.push(i);
                }
            }
            
            // Crush immediately and start cascade
            crushCandies({ indices: crushIndices, specialsToCreate: [] }); 
            renderBoard();
            await new Promise(resolve => setTimeout(resolve, 350));
            
            // Re-enter the loop to handle resulting cascades
            dropCandies();
            fillNewCandies();
            await gameLoop(); // Continue chain reaction
        };

        /**
         * Primary logic for handling a swap, including special candy interactions.
         */
        const handleSwap = async (index1, index2) => {
            const candy1 = board[index1];
            const candy2 = board[index2];
            
            // Check for Color Bomb interactions (Bomb + Regular Candy)
            if (isColorBomb(candy1) && BASE_CANDY_TYPES.includes(getBaseType(candy2))) {
                await activateColorBomb(index1, getBaseType(candy2));
                return true;
            } else if (isColorBomb(candy2) && BASE_CANDY_TYPES.includes(getBaseType(candy1))) {
                await activateColorBomb(index2, getBaseType(candy1));
                return true;
            } 

            // Standard Swap (or special swap that needs a match)
            swapCandies(index1, index2);
            await new Promise(resolve => setTimeout(resolve, 100));

            const matches = findMatches();
            
            if (matches.indices.length > 0) {
                // If the swap results in a match, run the full game loop
                await gameLoop();
                return true;
            } else {
                // Invalid move, swap back
                swapCandies(index1, index2);
                return false;
            }
        };


        /**
         * Handles the user clicking on a candy. 
         */
        const handleCandyClick = async (index) => {
            if (isProcessing || moves <= 0) return;

            const clickedEl = boardEl.children[index];

            if (selectedCandyIndex === -1) {
                selectedCandyIndex = index;
                clickedEl.classList.add('selected');
            } else if (selectedCandyIndex === index) {
                boardEl.children[selectedCandyIndex].classList.remove('selected');
                selectedCandyIndex = -1;
            } else if (isAdjacent(selectedCandyIndex, index)) {
                isProcessing = true;
                
                const index1 = selectedCandyIndex;
                const index2 = index;

                // Deselect before processing
                boardEl.children[index1].classList.remove('selected');
                selectedCandyIndex = -1;
                moves--;
                movesEl.textContent = moves; // Update moves regardless of match status, rollback happens in handleSwap

                const successfulSwap = await handleSwap(index1, index2);

                if (!successfulSwap) {
                    // If swap was not successful, it means it swapped back, so we undo the move count
                    moves++;
                    movesEl.textContent = moves; 
                    showMessage("No match! Swapping back.", 'text-red-400');
                }

                isProcessing = false;
                checkGameOver();
            } else {
                // Clicked non-adjacent candy: Select new
                if (selectedCandyIndex !== -1) boardEl.children[selectedCandyIndex].classList.remove('selected');
                selectedCandyIndex = index;
                clickedEl.classList.add('selected');
            }
        };

        /**
         * Finds all matches of 3 or more on the board, and identifies 4/5 matches.
         * @returns {{indices: number[], specialsToCreate: {index: number, type: string}[]}}
         */
        const findMatches = () => {
            const matches = new Set();
            const specialsToCreate = [];

            const checkLine = (lineIndices) => {
                let matchStart = -1;
                let matchLength = 0;
                let currentType = null;

                for (let i = 0; i <= lineIndices.length; i++) {
                    const index = lineIndices[i];
                    const candy = board[index];
                    const baseType = index !== undefined ? getBaseType(candy) : null;
                    
                    // Ignore nulls, specials, and the "rainbow" representation of the Color Bomb type
                    const isRegularCandy = baseType !== 'ðŸŒˆ' && BASE_CANDY_TYPES.includes(baseType);

                    if (isRegularCandy && baseType === currentType) {
                        matchLength++;
                    } else {
                        // End of a potential match
                        if (matchLength >= 3) {
                            // Record all matched indices
                            for (let j = 0; j < matchLength; j++) {
                                matches.add(lineIndices[matchStart + j]);
                            }
                            
                            // Check for special candy creation (only if it wasn't already a special)
                            if (matchLength === 4) {
                                // Create Striped at the start position of the match
                                const createIndex = lineIndices[matchStart];
                                if (!isStriped(board[createIndex]) && !isColorBomb(board[createIndex])) {
                                    specialsToCreate.push({ index: createIndex, type: currentType + STRIPED_SUFFIX });
                                }
                            } else if (matchLength >= 5) {
                                // Create Color Bomb at the start position
                                const createIndex = lineIndices[matchStart];
                                if (!isStriped(board[createIndex]) && !isColorBomb(board[createIndex])) {
                                    specialsToCreate.push({ index: createIndex, type: COLOR_BOMB_TYPE });
                                }
                            }
                        }
                        
                        // Reset for next potential match
                        matchStart = i;
                        currentType = baseType;
                        matchLength = 1;
                        if (!isRegularCandy) {
                            matchLength = 0; // Don't start a match count on null or special
                        }
                    }
                }
            };
            
            // 1. Check Rows
            for (let r = 0; r < GRID_SIZE; r++) {
                const rowIndices = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    rowIndices.push(coordsToIndex(r, c));
                }
                checkLine(rowIndices);
            }

            // 2. Check Columns
            for (let c = 0; c < GRID_SIZE; c++) {
                const colIndices = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    colIndices.push(coordsToIndex(r, c));
                }
                checkLine(colIndices);
            }

            return { indices: Array.from(matches), specialsToCreate };
        };
        
        /**
         * Activates a Striped Candy, clearing a row and column.
         */
        const activateStriped = (index) => {
            const { row, col } = indexToCoords(index);
            
            const rowIndices = [];
            for (let c = 0; c < GRID_SIZE; c++) rowIndices.push(coordsToIndex(row, c));
            
            const colIndices = [];
            for (let r = 0; r < GRID_SIZE; r++) colIndices.push(coordsToIndex(r, col));
            
            // Combine and get unique indices to avoid duplicates
            const allIndices = new Set([...rowIndices, ...colIndices]);
            showMessage("STRIPED CANDY BLAST! Row and column cleared!", 'text-blue-400');
            return Array.from(allIndices);
        };


        /**
         * Removes matched candies, activates special candies, and updates the score.
         * @param {{indices: number[], specialsToCreate: {index: number, type: string}[]}} matches
         */
        const crushCandies = (matches) => {
            const { indices, specialsToCreate } = matches;
            if (indices.length === 0) return;
            
            const allCrushIndices = new Set(indices);
            let crushCount = 0;

            // 1. Activate any special candies that are part of the match
            indices.forEach(index => {
                const candy = board[index];
                if (isStriped(candy)) {
                    // Activate striped and add its crush indices
                    const stripedCrushIndices = activateStriped(index);
                    stripedCrushIndices.forEach(i => allCrushIndices.add(i));
                }
                // Color Bombs are only activated via swap, not passive crush in this logic
            });

            // 2. Identify the index where the new special will be created (if any)
            let specialCreationIndex = -1;
            let specialType = null;

            if (specialsToCreate.length > 0) {
                // Find the index among the matched pieces that wasn't already a special
                // Simple: take the first one found by the line checker
                const candidate = specialsToCreate[0];
                specialCreationIndex = candidate.index;
                specialType = candidate.type;
            }

            // 3. Crush remaining indices (including activated special locations)
            allCrushIndices.forEach(index => {
                if (index === specialCreationIndex) {
                    // This is the location where a new special candy is created, so we replace it
                    board[index] = specialType;
                } else {
                    // Normal crush
                    board[index] = null;
                    crushCount++; // Count truly cleared tiles
                }
                
                // Add temporary class for visual "crush" effect
                const el = boardEl.children[index];
                if (el) {
                    el.classList.add('opacity-0', 'transition-opacity', 'duration-300', 'scale-50');
                }
            });

            // 4. Update score
            score += crushCount * 10;
            if(specialType) score += 50; // Bonus for creating a special
            scoreEl.textContent = score;
            showMessage(`CRUSH! +${crushCount * 10} points! ${specialType ? '(+50 Special Bonus!)' : ''}`, 'text-yellow-400');
        };

        /**
         * Simulates gravity by moving candies down to fill null spots.
         */
        const dropCandies = () => {
            // Iterate column by column
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySpots = 0;
                // Iterate from bottom row up
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    const index = coordsToIndex(r, c);

                    if (board[index] === null) {
                        emptySpots++;
                    } else if (emptySpots > 0) {
                        const newIndex = coordsToIndex(r + emptySpots, c);
                        board[newIndex] = board[index];
                        board[index] = null;
                    }
                }
            }
        };
        
        /**
         * Fills all remaining null spots with new random candies from the top.
         */
        const fillNewCandies = () => {
            for (let i = 0; i < board.length; i++) {
                if (board[i] === null) {
                    board[i] = getRandomCandy();
                }
            }
        };

        /**
         * The main recursive game loop to clear chains of matches.
         */
        const gameLoop = async () => {
            let matchesInfo;
            let loopCount = 0;
            do {
                matchesInfo = findMatches();
                if (matchesInfo.indices.length > 0) {
                    crushCandies(matchesInfo);
                    renderBoard(); // Render immediately after crush
                    
                    await new Promise(resolve => setTimeout(resolve, 350));
                    
                    dropCandies();
                    fillNewCandies();
                    renderBoard(); // Render after drop and fill

                    await new Promise(resolve => setTimeout(resolve, 550));
                    
                    loopCount++;
                }
            } while (matchesInfo.indices.length > 0 && loopCount < 100);

            if (loopCount > 1) {
                showMessage(`CHAIN COMBO! Cleared ${loopCount} times!`, 'text-pink-400');
            }
        };
        
        /**
         * Checks win/loss conditions and updates high score.
         */
        const checkGameOver = () => {
            if (moves <= 0) {
                isProcessing = true;
                let finalMessage = `Game Over! Your final score is ${score}.`;
                let color = 'text-red-500';

                // Check for new high score
                if (score > highScore) {
                    saveHighScore(score);
                    finalMessage = `NEW HIGH SCORE! ðŸ† ${score} points!`;
                    color = 'text-yellow-300';
                    highScoreEl.textContent = score; // Update display immediately
                } else if (score > 1000) {
                    finalMessage = `Amazing! You crushed it with ${score} points!`;
                    color = 'text-green-300';
                }

                // Ensures game over message is appropriately sized for mobile
                messageBox.innerHTML = `<span class="${color} text-xl md:text-2xl">${finalMessage}</span>`; 
                resetButton.textContent = "Play Again";
                resetButton.classList.remove('bg-indigo-600');
                resetButton.classList.add('bg-green-600');
            }
        };

        /**
         * Resets the game state.
         */
        const resetGame = () => {
            // Load high score first
            loadHighScore(); 

            // Reset other variables
            score = 0;
            moves = MOVES_LIMIT;
            selectedCandyIndex = -1;
            isProcessing = false;
            resetButton.textContent = "Start New Game";
            resetButton.classList.add('bg-indigo-600');
            resetButton.classList.remove('bg-green-600');
            createBoard();
            showMessage("Game reset! Let the crushing begin!");
        };

        // --- Event Listeners and Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            resetButton.addEventListener('click', resetGame);
            resetGame(); // Start the first game
        });
    </script>

</body>
</html>